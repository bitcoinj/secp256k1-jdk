/*
 * Copyright 2023-2024 secp256k1-jdk Developers.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by jextract

package org.bitcoinj.secp.ffm.jextract;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class secp256k1_h {

    secp256k1_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.findOrThrow(symbol);
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }


    static {
        System.loadLibrary("secp256k1");
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get("bool");
    public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get("char");
    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get("short");
    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get("int");
    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get("long long");
    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get("float");
    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get("double");
    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get("void*"))
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));
    public static final ValueLayout.OfLong C_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get("long");
    private static final int SECP256K1_TAG_PUBKEY_EVEN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_TAG_PUBKEY_EVEN 2
     * }
     */
    public static int SECP256K1_TAG_PUBKEY_EVEN() {
        return SECP256K1_TAG_PUBKEY_EVEN;
    }
    private static final int SECP256K1_TAG_PUBKEY_ODD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_TAG_PUBKEY_ODD 3
     * }
     */
    public static int SECP256K1_TAG_PUBKEY_ODD() {
        return SECP256K1_TAG_PUBKEY_ODD;
    }
    private static final int SECP256K1_TAG_PUBKEY_UNCOMPRESSED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_TAG_PUBKEY_UNCOMPRESSED 4
     * }
     */
    public static int SECP256K1_TAG_PUBKEY_UNCOMPRESSED() {
        return SECP256K1_TAG_PUBKEY_UNCOMPRESSED;
    }
    private static final int SECP256K1_TAG_PUBKEY_HYBRID_EVEN = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_TAG_PUBKEY_HYBRID_EVEN 6
     * }
     */
    public static int SECP256K1_TAG_PUBKEY_HYBRID_EVEN() {
        return SECP256K1_TAG_PUBKEY_HYBRID_EVEN;
    }
    private static final int SECP256K1_TAG_PUBKEY_HYBRID_ODD = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_TAG_PUBKEY_HYBRID_ODD 7
     * }
     */
    public static int SECP256K1_TAG_PUBKEY_HYBRID_ODD() {
        return SECP256K1_TAG_PUBKEY_HYBRID_ODD;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = secp256k1_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = secp256k1_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = secp256k1_h.C_INT;

    private static class secp256k1_context_static$constants {
        public static final AddressLayout LAYOUT = secp256k1_h.C_POINTER;
        public static final MemorySegment SEGMENT = secp256k1_h.findOrThrow("secp256k1_context_static").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const secp256k1_context *secp256k1_context_static
     * }
     */
    public static AddressLayout secp256k1_context_static$layout() {
        return secp256k1_context_static$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const secp256k1_context *secp256k1_context_static
     * }
     */
    public static MemorySegment secp256k1_context_static$segment() {
        return secp256k1_context_static$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_context *secp256k1_context_static
     * }
     */
    public static MemorySegment secp256k1_context_static() {
        return secp256k1_context_static$constants.SEGMENT.get(secp256k1_context_static$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_context *secp256k1_context_static
     * }
     */
    public static void secp256k1_context_static(MemorySegment varValue) {
        secp256k1_context_static$constants.SEGMENT.set(secp256k1_context_static$constants.LAYOUT, 0L, varValue);
    }

    private static class secp256k1_context_no_precomp$constants {
        public static final AddressLayout LAYOUT = secp256k1_h.C_POINTER;
        public static final MemorySegment SEGMENT = secp256k1_h.findOrThrow("secp256k1_context_no_precomp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const secp256k1_context *secp256k1_context_no_precomp
     * }
     */
    public static AddressLayout secp256k1_context_no_precomp$layout() {
        return secp256k1_context_no_precomp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const secp256k1_context *secp256k1_context_no_precomp
     * }
     */
    public static MemorySegment secp256k1_context_no_precomp$segment() {
        return secp256k1_context_no_precomp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_context *secp256k1_context_no_precomp
     * }
     */
    public static MemorySegment secp256k1_context_no_precomp() {
        return secp256k1_context_no_precomp$constants.SEGMENT.get(secp256k1_context_no_precomp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_context *secp256k1_context_no_precomp
     * }
     */
    public static void secp256k1_context_no_precomp(MemorySegment varValue) {
        secp256k1_context_no_precomp$constants.SEGMENT.set(secp256k1_context_no_precomp$constants.LAYOUT, 0L, varValue);
    }

    private static class secp256k1_selftest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_selftest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void secp256k1_selftest(void)
     * }
     */
    public static FunctionDescriptor secp256k1_selftest$descriptor() {
        return secp256k1_selftest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void secp256k1_selftest(void)
     * }
     */
    public static MethodHandle secp256k1_selftest$handle() {
        return secp256k1_selftest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void secp256k1_selftest(void)
     * }
     */
    public static MemorySegment secp256k1_selftest$address() {
        return secp256k1_selftest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void secp256k1_selftest(void)
     * }
     */
    public static void secp256k1_selftest() {
        var mh$ = secp256k1_selftest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_selftest");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_context_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_POINTER,
            secp256k1_h.C_INT
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_context_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern secp256k1_context *secp256k1_context_create(unsigned int flags)
     * }
     */
    public static FunctionDescriptor secp256k1_context_create$descriptor() {
        return secp256k1_context_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern secp256k1_context *secp256k1_context_create(unsigned int flags)
     * }
     */
    public static MethodHandle secp256k1_context_create$handle() {
        return secp256k1_context_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern secp256k1_context *secp256k1_context_create(unsigned int flags)
     * }
     */
    public static MemorySegment secp256k1_context_create$address() {
        return secp256k1_context_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern secp256k1_context *secp256k1_context_create(unsigned int flags)
     * }
     */
    public static MemorySegment secp256k1_context_create(int flags) {
        var mh$ = secp256k1_context_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_context_create", flags);
            }
            return (MemorySegment)mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_context_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_context_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern secp256k1_context *secp256k1_context_clone(const secp256k1_context *ctx)
     * }
     */
    public static FunctionDescriptor secp256k1_context_clone$descriptor() {
        return secp256k1_context_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern secp256k1_context *secp256k1_context_clone(const secp256k1_context *ctx)
     * }
     */
    public static MethodHandle secp256k1_context_clone$handle() {
        return secp256k1_context_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern secp256k1_context *secp256k1_context_clone(const secp256k1_context *ctx)
     * }
     */
    public static MemorySegment secp256k1_context_clone$address() {
        return secp256k1_context_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern secp256k1_context *secp256k1_context_clone(const secp256k1_context *ctx)
     * }
     */
    public static MemorySegment secp256k1_context_clone(MemorySegment ctx) {
        var mh$ = secp256k1_context_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_context_clone", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_context_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_context_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void secp256k1_context_destroy(secp256k1_context *ctx)
     * }
     */
    public static FunctionDescriptor secp256k1_context_destroy$descriptor() {
        return secp256k1_context_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void secp256k1_context_destroy(secp256k1_context *ctx)
     * }
     */
    public static MethodHandle secp256k1_context_destroy$handle() {
        return secp256k1_context_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void secp256k1_context_destroy(secp256k1_context *ctx)
     * }
     */
    public static MemorySegment secp256k1_context_destroy$address() {
        return secp256k1_context_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void secp256k1_context_destroy(secp256k1_context *ctx)
     * }
     */
    public static void secp256k1_context_destroy(MemorySegment ctx) {
        var mh$ = secp256k1_context_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_context_destroy", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_context_set_illegal_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_context_set_illegal_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void secp256k1_context_set_illegal_callback(secp256k1_context *ctx, void (*fun)(const char *, void *), const void *data)
     * }
     */
    public static FunctionDescriptor secp256k1_context_set_illegal_callback$descriptor() {
        return secp256k1_context_set_illegal_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void secp256k1_context_set_illegal_callback(secp256k1_context *ctx, void (*fun)(const char *, void *), const void *data)
     * }
     */
    public static MethodHandle secp256k1_context_set_illegal_callback$handle() {
        return secp256k1_context_set_illegal_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void secp256k1_context_set_illegal_callback(secp256k1_context *ctx, void (*fun)(const char *, void *), const void *data)
     * }
     */
    public static MemorySegment secp256k1_context_set_illegal_callback$address() {
        return secp256k1_context_set_illegal_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void secp256k1_context_set_illegal_callback(secp256k1_context *ctx, void (*fun)(const char *, void *), const void *data)
     * }
     */
    public static void secp256k1_context_set_illegal_callback(MemorySegment ctx, MemorySegment fun, MemorySegment data) {
        var mh$ = secp256k1_context_set_illegal_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_context_set_illegal_callback", ctx, fun, data);
            }
            mh$.invokeExact(ctx, fun, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_context_set_error_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_context_set_error_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void secp256k1_context_set_error_callback(secp256k1_context *ctx, void (*fun)(const char *, void *), const void *data)
     * }
     */
    public static FunctionDescriptor secp256k1_context_set_error_callback$descriptor() {
        return secp256k1_context_set_error_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void secp256k1_context_set_error_callback(secp256k1_context *ctx, void (*fun)(const char *, void *), const void *data)
     * }
     */
    public static MethodHandle secp256k1_context_set_error_callback$handle() {
        return secp256k1_context_set_error_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void secp256k1_context_set_error_callback(secp256k1_context *ctx, void (*fun)(const char *, void *), const void *data)
     * }
     */
    public static MemorySegment secp256k1_context_set_error_callback$address() {
        return secp256k1_context_set_error_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void secp256k1_context_set_error_callback(secp256k1_context *ctx, void (*fun)(const char *, void *), const void *data)
     * }
     */
    public static void secp256k1_context_set_error_callback(MemorySegment ctx, MemorySegment fun, MemorySegment data) {
        var mh$ = secp256k1_context_set_error_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_context_set_error_callback", ctx, fun, data);
            }
            mh$.invokeExact(ctx, fun, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_pubkey_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_LONG
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_pubkey_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_parse(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *input, size_t inputlen)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_pubkey_parse$descriptor() {
        return secp256k1_ec_pubkey_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_parse(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *input, size_t inputlen)
     * }
     */
    public static MethodHandle secp256k1_ec_pubkey_parse$handle() {
        return secp256k1_ec_pubkey_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_parse(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *input, size_t inputlen)
     * }
     */
    public static MemorySegment secp256k1_ec_pubkey_parse$address() {
        return secp256k1_ec_pubkey_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_parse(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *input, size_t inputlen)
     * }
     */
    public static int secp256k1_ec_pubkey_parse(MemorySegment ctx, MemorySegment pubkey, MemorySegment input, long inputlen) {
        var mh$ = secp256k1_ec_pubkey_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_pubkey_parse", ctx, pubkey, input, inputlen);
            }
            return (int)mh$.invokeExact(ctx, pubkey, input, inputlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_pubkey_serialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_INT
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_pubkey_serialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_serialize(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_pubkey *pubkey, unsigned int flags)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_pubkey_serialize$descriptor() {
        return secp256k1_ec_pubkey_serialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_serialize(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_pubkey *pubkey, unsigned int flags)
     * }
     */
    public static MethodHandle secp256k1_ec_pubkey_serialize$handle() {
        return secp256k1_ec_pubkey_serialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_serialize(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_pubkey *pubkey, unsigned int flags)
     * }
     */
    public static MemorySegment secp256k1_ec_pubkey_serialize$address() {
        return secp256k1_ec_pubkey_serialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_serialize(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_pubkey *pubkey, unsigned int flags)
     * }
     */
    public static int secp256k1_ec_pubkey_serialize(MemorySegment ctx, MemorySegment output, MemorySegment outputlen, MemorySegment pubkey, int flags) {
        var mh$ = secp256k1_ec_pubkey_serialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_pubkey_serialize", ctx, output, outputlen, pubkey, flags);
            }
            return (int)mh$.invokeExact(ctx, output, outputlen, pubkey, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_pubkey_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_pubkey_cmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_cmp(const secp256k1_context *ctx, const secp256k1_pubkey *pubkey1, const secp256k1_pubkey *pubkey2)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_pubkey_cmp$descriptor() {
        return secp256k1_ec_pubkey_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_cmp(const secp256k1_context *ctx, const secp256k1_pubkey *pubkey1, const secp256k1_pubkey *pubkey2)
     * }
     */
    public static MethodHandle secp256k1_ec_pubkey_cmp$handle() {
        return secp256k1_ec_pubkey_cmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_cmp(const secp256k1_context *ctx, const secp256k1_pubkey *pubkey1, const secp256k1_pubkey *pubkey2)
     * }
     */
    public static MemorySegment secp256k1_ec_pubkey_cmp$address() {
        return secp256k1_ec_pubkey_cmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_cmp(const secp256k1_context *ctx, const secp256k1_pubkey *pubkey1, const secp256k1_pubkey *pubkey2)
     * }
     */
    public static int secp256k1_ec_pubkey_cmp(MemorySegment ctx, MemorySegment pubkey1, MemorySegment pubkey2) {
        var mh$ = secp256k1_ec_pubkey_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_pubkey_cmp", ctx, pubkey1, pubkey2);
            }
            return (int)mh$.invokeExact(ctx, pubkey1, pubkey2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_pubkey_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_LONG
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_pubkey_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_sort(const secp256k1_context *ctx, const secp256k1_pubkey **pubkeys, size_t n_pubkeys)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_pubkey_sort$descriptor() {
        return secp256k1_ec_pubkey_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_sort(const secp256k1_context *ctx, const secp256k1_pubkey **pubkeys, size_t n_pubkeys)
     * }
     */
    public static MethodHandle secp256k1_ec_pubkey_sort$handle() {
        return secp256k1_ec_pubkey_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_sort(const secp256k1_context *ctx, const secp256k1_pubkey **pubkeys, size_t n_pubkeys)
     * }
     */
    public static MemorySegment secp256k1_ec_pubkey_sort$address() {
        return secp256k1_ec_pubkey_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_sort(const secp256k1_context *ctx, const secp256k1_pubkey **pubkeys, size_t n_pubkeys)
     * }
     */
    public static int secp256k1_ec_pubkey_sort(MemorySegment ctx, MemorySegment pubkeys, long n_pubkeys) {
        var mh$ = secp256k1_ec_pubkey_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_pubkey_sort", ctx, pubkeys, n_pubkeys);
            }
            return (int)mh$.invokeExact(ctx, pubkeys, n_pubkeys);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ecdsa_signature_parse_compact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ecdsa_signature_parse_compact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input64)
     * }
     */
    public static FunctionDescriptor secp256k1_ecdsa_signature_parse_compact$descriptor() {
        return secp256k1_ecdsa_signature_parse_compact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input64)
     * }
     */
    public static MethodHandle secp256k1_ecdsa_signature_parse_compact$handle() {
        return secp256k1_ecdsa_signature_parse_compact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input64)
     * }
     */
    public static MemorySegment secp256k1_ecdsa_signature_parse_compact$address() {
        return secp256k1_ecdsa_signature_parse_compact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_parse_compact(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input64)
     * }
     */
    public static int secp256k1_ecdsa_signature_parse_compact(MemorySegment ctx, MemorySegment sig, MemorySegment input64) {
        var mh$ = secp256k1_ecdsa_signature_parse_compact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ecdsa_signature_parse_compact", ctx, sig, input64);
            }
            return (int)mh$.invokeExact(ctx, sig, input64);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ecdsa_signature_parse_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_LONG
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ecdsa_signature_parse_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_parse_der(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input, size_t inputlen)
     * }
     */
    public static FunctionDescriptor secp256k1_ecdsa_signature_parse_der$descriptor() {
        return secp256k1_ecdsa_signature_parse_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_parse_der(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input, size_t inputlen)
     * }
     */
    public static MethodHandle secp256k1_ecdsa_signature_parse_der$handle() {
        return secp256k1_ecdsa_signature_parse_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_parse_der(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input, size_t inputlen)
     * }
     */
    public static MemorySegment secp256k1_ecdsa_signature_parse_der$address() {
        return secp256k1_ecdsa_signature_parse_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_parse_der(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input, size_t inputlen)
     * }
     */
    public static int secp256k1_ecdsa_signature_parse_der(MemorySegment ctx, MemorySegment sig, MemorySegment input, long inputlen) {
        var mh$ = secp256k1_ecdsa_signature_parse_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ecdsa_signature_parse_der", ctx, sig, input, inputlen);
            }
            return (int)mh$.invokeExact(ctx, sig, input, inputlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ecdsa_signature_serialize_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ecdsa_signature_serialize_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature *sig)
     * }
     */
    public static FunctionDescriptor secp256k1_ecdsa_signature_serialize_der$descriptor() {
        return secp256k1_ecdsa_signature_serialize_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature *sig)
     * }
     */
    public static MethodHandle secp256k1_ecdsa_signature_serialize_der$handle() {
        return secp256k1_ecdsa_signature_serialize_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature *sig)
     * }
     */
    public static MemorySegment secp256k1_ecdsa_signature_serialize_der$address() {
        return secp256k1_ecdsa_signature_serialize_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_serialize_der(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature *sig)
     * }
     */
    public static int secp256k1_ecdsa_signature_serialize_der(MemorySegment ctx, MemorySegment output, MemorySegment outputlen, MemorySegment sig) {
        var mh$ = secp256k1_ecdsa_signature_serialize_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ecdsa_signature_serialize_der", ctx, output, outputlen, sig);
            }
            return (int)mh$.invokeExact(ctx, output, outputlen, sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ecdsa_signature_serialize_compact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ecdsa_signature_serialize_compact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_serialize_compact(const secp256k1_context *ctx, unsigned char *output64, const secp256k1_ecdsa_signature *sig)
     * }
     */
    public static FunctionDescriptor secp256k1_ecdsa_signature_serialize_compact$descriptor() {
        return secp256k1_ecdsa_signature_serialize_compact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_serialize_compact(const secp256k1_context *ctx, unsigned char *output64, const secp256k1_ecdsa_signature *sig)
     * }
     */
    public static MethodHandle secp256k1_ecdsa_signature_serialize_compact$handle() {
        return secp256k1_ecdsa_signature_serialize_compact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_serialize_compact(const secp256k1_context *ctx, unsigned char *output64, const secp256k1_ecdsa_signature *sig)
     * }
     */
    public static MemorySegment secp256k1_ecdsa_signature_serialize_compact$address() {
        return secp256k1_ecdsa_signature_serialize_compact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_serialize_compact(const secp256k1_context *ctx, unsigned char *output64, const secp256k1_ecdsa_signature *sig)
     * }
     */
    public static int secp256k1_ecdsa_signature_serialize_compact(MemorySegment ctx, MemorySegment output64, MemorySegment sig) {
        var mh$ = secp256k1_ecdsa_signature_serialize_compact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ecdsa_signature_serialize_compact", ctx, output64, sig);
            }
            return (int)mh$.invokeExact(ctx, output64, sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ecdsa_verify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ecdsa_verify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_verify(const secp256k1_context *ctx, const secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const secp256k1_pubkey *pubkey)
     * }
     */
    public static FunctionDescriptor secp256k1_ecdsa_verify$descriptor() {
        return secp256k1_ecdsa_verify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_verify(const secp256k1_context *ctx, const secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const secp256k1_pubkey *pubkey)
     * }
     */
    public static MethodHandle secp256k1_ecdsa_verify$handle() {
        return secp256k1_ecdsa_verify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_verify(const secp256k1_context *ctx, const secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const secp256k1_pubkey *pubkey)
     * }
     */
    public static MemorySegment secp256k1_ecdsa_verify$address() {
        return secp256k1_ecdsa_verify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_verify(const secp256k1_context *ctx, const secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const secp256k1_pubkey *pubkey)
     * }
     */
    public static int secp256k1_ecdsa_verify(MemorySegment ctx, MemorySegment sig, MemorySegment msghash32, MemorySegment pubkey) {
        var mh$ = secp256k1_ecdsa_verify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ecdsa_verify", ctx, sig, msghash32, pubkey);
            }
            return (int)mh$.invokeExact(ctx, sig, msghash32, pubkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ecdsa_signature_normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ecdsa_signature_normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_normalize(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sigout, const secp256k1_ecdsa_signature *sigin)
     * }
     */
    public static FunctionDescriptor secp256k1_ecdsa_signature_normalize$descriptor() {
        return secp256k1_ecdsa_signature_normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_normalize(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sigout, const secp256k1_ecdsa_signature *sigin)
     * }
     */
    public static MethodHandle secp256k1_ecdsa_signature_normalize$handle() {
        return secp256k1_ecdsa_signature_normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_normalize(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sigout, const secp256k1_ecdsa_signature *sigin)
     * }
     */
    public static MemorySegment secp256k1_ecdsa_signature_normalize$address() {
        return secp256k1_ecdsa_signature_normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_signature_normalize(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sigout, const secp256k1_ecdsa_signature *sigin)
     * }
     */
    public static int secp256k1_ecdsa_signature_normalize(MemorySegment ctx, MemorySegment sigout, MemorySegment sigin) {
        var mh$ = secp256k1_ecdsa_signature_normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ecdsa_signature_normalize", ctx, sigout, sigin);
            }
            return (int)mh$.invokeExact(ctx, sigout, sigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_nonce_function_rfc6979$constants {
        public static final AddressLayout LAYOUT = secp256k1_h.C_POINTER;
        public static final MemorySegment SEGMENT = secp256k1_h.findOrThrow("secp256k1_nonce_function_rfc6979").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979
     * }
     */
    public static AddressLayout secp256k1_nonce_function_rfc6979$layout() {
        return secp256k1_nonce_function_rfc6979$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979
     * }
     */
    public static MemorySegment secp256k1_nonce_function_rfc6979$segment() {
        return secp256k1_nonce_function_rfc6979$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979
     * }
     */
    public static MemorySegment secp256k1_nonce_function_rfc6979() {
        return secp256k1_nonce_function_rfc6979$constants.SEGMENT.get(secp256k1_nonce_function_rfc6979$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function secp256k1_nonce_function_rfc6979
     * }
     */
    public static void secp256k1_nonce_function_rfc6979(MemorySegment varValue) {
        secp256k1_nonce_function_rfc6979$constants.SEGMENT.set(secp256k1_nonce_function_rfc6979$constants.LAYOUT, 0L, varValue);
    }

    private static class secp256k1_nonce_function_default$constants {
        public static final AddressLayout LAYOUT = secp256k1_h.C_POINTER;
        public static final MemorySegment SEGMENT = secp256k1_h.findOrThrow("secp256k1_nonce_function_default").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function secp256k1_nonce_function_default
     * }
     */
    public static AddressLayout secp256k1_nonce_function_default$layout() {
        return secp256k1_nonce_function_default$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function secp256k1_nonce_function_default
     * }
     */
    public static MemorySegment secp256k1_nonce_function_default$segment() {
        return secp256k1_nonce_function_default$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function secp256k1_nonce_function_default
     * }
     */
    public static MemorySegment secp256k1_nonce_function_default() {
        return secp256k1_nonce_function_default$constants.SEGMENT.get(secp256k1_nonce_function_default$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function secp256k1_nonce_function_default
     * }
     */
    public static void secp256k1_nonce_function_default(MemorySegment varValue) {
        secp256k1_nonce_function_default$constants.SEGMENT.set(secp256k1_nonce_function_default$constants.LAYOUT, 0L, varValue);
    }

    private static class secp256k1_ecdsa_sign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ecdsa_sign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_sign(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata)
     * }
     */
    public static FunctionDescriptor secp256k1_ecdsa_sign$descriptor() {
        return secp256k1_ecdsa_sign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_sign(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata)
     * }
     */
    public static MethodHandle secp256k1_ecdsa_sign$handle() {
        return secp256k1_ecdsa_sign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_sign(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata)
     * }
     */
    public static MemorySegment secp256k1_ecdsa_sign$address() {
        return secp256k1_ecdsa_sign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ecdsa_sign(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata)
     * }
     */
    public static int secp256k1_ecdsa_sign(MemorySegment ctx, MemorySegment sig, MemorySegment msghash32, MemorySegment seckey, MemorySegment noncefp, MemorySegment ndata) {
        var mh$ = secp256k1_ecdsa_sign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ecdsa_sign", ctx, sig, msghash32, seckey, noncefp, ndata);
            }
            return (int)mh$.invokeExact(ctx, sig, msghash32, seckey, noncefp, ndata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_seckey_verify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_seckey_verify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_verify(const secp256k1_context *ctx, const unsigned char *seckey)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_seckey_verify$descriptor() {
        return secp256k1_ec_seckey_verify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_verify(const secp256k1_context *ctx, const unsigned char *seckey)
     * }
     */
    public static MethodHandle secp256k1_ec_seckey_verify$handle() {
        return secp256k1_ec_seckey_verify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_verify(const secp256k1_context *ctx, const unsigned char *seckey)
     * }
     */
    public static MemorySegment secp256k1_ec_seckey_verify$address() {
        return secp256k1_ec_seckey_verify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_verify(const secp256k1_context *ctx, const unsigned char *seckey)
     * }
     */
    public static int secp256k1_ec_seckey_verify(MemorySegment ctx, MemorySegment seckey) {
        var mh$ = secp256k1_ec_seckey_verify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_seckey_verify", ctx, seckey);
            }
            return (int)mh$.invokeExact(ctx, seckey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_pubkey_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_pubkey_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_create(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_pubkey_create$descriptor() {
        return secp256k1_ec_pubkey_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_create(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey)
     * }
     */
    public static MethodHandle secp256k1_ec_pubkey_create$handle() {
        return secp256k1_ec_pubkey_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_create(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey)
     * }
     */
    public static MemorySegment secp256k1_ec_pubkey_create$address() {
        return secp256k1_ec_pubkey_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_create(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey)
     * }
     */
    public static int secp256k1_ec_pubkey_create(MemorySegment ctx, MemorySegment pubkey, MemorySegment seckey) {
        var mh$ = secp256k1_ec_pubkey_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_pubkey_create", ctx, pubkey, seckey);
            }
            return (int)mh$.invokeExact(ctx, pubkey, seckey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_seckey_negate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_seckey_negate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_negate(const secp256k1_context *ctx, unsigned char *seckey)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_seckey_negate$descriptor() {
        return secp256k1_ec_seckey_negate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_negate(const secp256k1_context *ctx, unsigned char *seckey)
     * }
     */
    public static MethodHandle secp256k1_ec_seckey_negate$handle() {
        return secp256k1_ec_seckey_negate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_negate(const secp256k1_context *ctx, unsigned char *seckey)
     * }
     */
    public static MemorySegment secp256k1_ec_seckey_negate$address() {
        return secp256k1_ec_seckey_negate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_negate(const secp256k1_context *ctx, unsigned char *seckey)
     * }
     */
    public static int secp256k1_ec_seckey_negate(MemorySegment ctx, MemorySegment seckey) {
        var mh$ = secp256k1_ec_seckey_negate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_seckey_negate", ctx, seckey);
            }
            return (int)mh$.invokeExact(ctx, seckey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_privkey_negate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_privkey_negate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_negate(const secp256k1_context *ctx, unsigned char *seckey)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_privkey_negate$descriptor() {
        return secp256k1_ec_privkey_negate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_negate(const secp256k1_context *ctx, unsigned char *seckey)
     * }
     */
    public static MethodHandle secp256k1_ec_privkey_negate$handle() {
        return secp256k1_ec_privkey_negate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_negate(const secp256k1_context *ctx, unsigned char *seckey)
     * }
     */
    public static MemorySegment secp256k1_ec_privkey_negate$address() {
        return secp256k1_ec_privkey_negate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_negate(const secp256k1_context *ctx, unsigned char *seckey)
     * }
     */
    public static int secp256k1_ec_privkey_negate(MemorySegment ctx, MemorySegment seckey) {
        var mh$ = secp256k1_ec_privkey_negate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_privkey_negate", ctx, seckey);
            }
            return (int)mh$.invokeExact(ctx, seckey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_pubkey_negate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_pubkey_negate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_negate(const secp256k1_context *ctx, secp256k1_pubkey *pubkey)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_pubkey_negate$descriptor() {
        return secp256k1_ec_pubkey_negate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_negate(const secp256k1_context *ctx, secp256k1_pubkey *pubkey)
     * }
     */
    public static MethodHandle secp256k1_ec_pubkey_negate$handle() {
        return secp256k1_ec_pubkey_negate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_negate(const secp256k1_context *ctx, secp256k1_pubkey *pubkey)
     * }
     */
    public static MemorySegment secp256k1_ec_pubkey_negate$address() {
        return secp256k1_ec_pubkey_negate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_negate(const secp256k1_context *ctx, secp256k1_pubkey *pubkey)
     * }
     */
    public static int secp256k1_ec_pubkey_negate(MemorySegment ctx, MemorySegment pubkey) {
        var mh$ = secp256k1_ec_pubkey_negate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_pubkey_negate", ctx, pubkey);
            }
            return (int)mh$.invokeExact(ctx, pubkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_seckey_tweak_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_seckey_tweak_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_tweak_add(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_seckey_tweak_add$descriptor() {
        return secp256k1_ec_seckey_tweak_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_tweak_add(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static MethodHandle secp256k1_ec_seckey_tweak_add$handle() {
        return secp256k1_ec_seckey_tweak_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_tweak_add(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static MemorySegment secp256k1_ec_seckey_tweak_add$address() {
        return secp256k1_ec_seckey_tweak_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_tweak_add(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static int secp256k1_ec_seckey_tweak_add(MemorySegment ctx, MemorySegment seckey, MemorySegment tweak32) {
        var mh$ = secp256k1_ec_seckey_tweak_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_seckey_tweak_add", ctx, seckey, tweak32);
            }
            return (int)mh$.invokeExact(ctx, seckey, tweak32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_privkey_tweak_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_privkey_tweak_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_tweak_add(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_privkey_tweak_add$descriptor() {
        return secp256k1_ec_privkey_tweak_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_tweak_add(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static MethodHandle secp256k1_ec_privkey_tweak_add$handle() {
        return secp256k1_ec_privkey_tweak_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_tweak_add(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static MemorySegment secp256k1_ec_privkey_tweak_add$address() {
        return secp256k1_ec_privkey_tweak_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_tweak_add(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static int secp256k1_ec_privkey_tweak_add(MemorySegment ctx, MemorySegment seckey, MemorySegment tweak32) {
        var mh$ = secp256k1_ec_privkey_tweak_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_privkey_tweak_add", ctx, seckey, tweak32);
            }
            return (int)mh$.invokeExact(ctx, seckey, tweak32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_pubkey_tweak_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_pubkey_tweak_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_tweak_add(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_pubkey_tweak_add$descriptor() {
        return secp256k1_ec_pubkey_tweak_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_tweak_add(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32)
     * }
     */
    public static MethodHandle secp256k1_ec_pubkey_tweak_add$handle() {
        return secp256k1_ec_pubkey_tweak_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_tweak_add(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32)
     * }
     */
    public static MemorySegment secp256k1_ec_pubkey_tweak_add$address() {
        return secp256k1_ec_pubkey_tweak_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_tweak_add(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32)
     * }
     */
    public static int secp256k1_ec_pubkey_tweak_add(MemorySegment ctx, MemorySegment pubkey, MemorySegment tweak32) {
        var mh$ = secp256k1_ec_pubkey_tweak_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_pubkey_tweak_add", ctx, pubkey, tweak32);
            }
            return (int)mh$.invokeExact(ctx, pubkey, tweak32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_seckey_tweak_mul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_seckey_tweak_mul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_tweak_mul(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_seckey_tweak_mul$descriptor() {
        return secp256k1_ec_seckey_tweak_mul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_tweak_mul(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static MethodHandle secp256k1_ec_seckey_tweak_mul$handle() {
        return secp256k1_ec_seckey_tweak_mul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_tweak_mul(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static MemorySegment secp256k1_ec_seckey_tweak_mul$address() {
        return secp256k1_ec_seckey_tweak_mul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_seckey_tweak_mul(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static int secp256k1_ec_seckey_tweak_mul(MemorySegment ctx, MemorySegment seckey, MemorySegment tweak32) {
        var mh$ = secp256k1_ec_seckey_tweak_mul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_seckey_tweak_mul", ctx, seckey, tweak32);
            }
            return (int)mh$.invokeExact(ctx, seckey, tweak32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_privkey_tweak_mul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_privkey_tweak_mul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_tweak_mul(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_privkey_tweak_mul$descriptor() {
        return secp256k1_ec_privkey_tweak_mul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_tweak_mul(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static MethodHandle secp256k1_ec_privkey_tweak_mul$handle() {
        return secp256k1_ec_privkey_tweak_mul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_tweak_mul(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static MemorySegment secp256k1_ec_privkey_tweak_mul$address() {
        return secp256k1_ec_privkey_tweak_mul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_privkey_tweak_mul(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)
     * }
     */
    public static int secp256k1_ec_privkey_tweak_mul(MemorySegment ctx, MemorySegment seckey, MemorySegment tweak32) {
        var mh$ = secp256k1_ec_privkey_tweak_mul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_privkey_tweak_mul", ctx, seckey, tweak32);
            }
            return (int)mh$.invokeExact(ctx, seckey, tweak32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_pubkey_tweak_mul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_pubkey_tweak_mul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_pubkey_tweak_mul$descriptor() {
        return secp256k1_ec_pubkey_tweak_mul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32)
     * }
     */
    public static MethodHandle secp256k1_ec_pubkey_tweak_mul$handle() {
        return secp256k1_ec_pubkey_tweak_mul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32)
     * }
     */
    public static MemorySegment secp256k1_ec_pubkey_tweak_mul$address() {
        return secp256k1_ec_pubkey_tweak_mul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32)
     * }
     */
    public static int secp256k1_ec_pubkey_tweak_mul(MemorySegment ctx, MemorySegment pubkey, MemorySegment tweak32) {
        var mh$ = secp256k1_ec_pubkey_tweak_mul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_pubkey_tweak_mul", ctx, pubkey, tweak32);
            }
            return (int)mh$.invokeExact(ctx, pubkey, tweak32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_context_randomize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_context_randomize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_context_randomize(secp256k1_context *ctx, const unsigned char *seed32)
     * }
     */
    public static FunctionDescriptor secp256k1_context_randomize$descriptor() {
        return secp256k1_context_randomize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_context_randomize(secp256k1_context *ctx, const unsigned char *seed32)
     * }
     */
    public static MethodHandle secp256k1_context_randomize$handle() {
        return secp256k1_context_randomize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_context_randomize(secp256k1_context *ctx, const unsigned char *seed32)
     * }
     */
    public static MemorySegment secp256k1_context_randomize$address() {
        return secp256k1_context_randomize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_context_randomize(secp256k1_context *ctx, const unsigned char *seed32)
     * }
     */
    public static int secp256k1_context_randomize(MemorySegment ctx, MemorySegment seed32) {
        var mh$ = secp256k1_context_randomize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_context_randomize", ctx, seed32);
            }
            return (int)mh$.invokeExact(ctx, seed32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ec_pubkey_combine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_LONG
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ec_pubkey_combine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_combine(const secp256k1_context *ctx, secp256k1_pubkey *out, const secp256k1_pubkey *const *ins, size_t n)
     * }
     */
    public static FunctionDescriptor secp256k1_ec_pubkey_combine$descriptor() {
        return secp256k1_ec_pubkey_combine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_combine(const secp256k1_context *ctx, secp256k1_pubkey *out, const secp256k1_pubkey *const *ins, size_t n)
     * }
     */
    public static MethodHandle secp256k1_ec_pubkey_combine$handle() {
        return secp256k1_ec_pubkey_combine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_combine(const secp256k1_context *ctx, secp256k1_pubkey *out, const secp256k1_pubkey *const *ins, size_t n)
     * }
     */
    public static MemorySegment secp256k1_ec_pubkey_combine$address() {
        return secp256k1_ec_pubkey_combine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ec_pubkey_combine(const secp256k1_context *ctx, secp256k1_pubkey *out, const secp256k1_pubkey *const *ins, size_t n)
     * }
     */
    public static int secp256k1_ec_pubkey_combine(MemorySegment ctx, MemorySegment out, MemorySegment ins, long n) {
        var mh$ = secp256k1_ec_pubkey_combine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ec_pubkey_combine", ctx, out, ins, n);
            }
            return (int)mh$.invokeExact(ctx, out, ins, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_tagged_sha256 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_LONG,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_LONG
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_tagged_sha256");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_tagged_sha256(const secp256k1_context *ctx, unsigned char *hash32, const unsigned char *tag, size_t taglen, const unsigned char *msg, size_t msglen)
     * }
     */
    public static FunctionDescriptor secp256k1_tagged_sha256$descriptor() {
        return secp256k1_tagged_sha256.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_tagged_sha256(const secp256k1_context *ctx, unsigned char *hash32, const unsigned char *tag, size_t taglen, const unsigned char *msg, size_t msglen)
     * }
     */
    public static MethodHandle secp256k1_tagged_sha256$handle() {
        return secp256k1_tagged_sha256.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_tagged_sha256(const secp256k1_context *ctx, unsigned char *hash32, const unsigned char *tag, size_t taglen, const unsigned char *msg, size_t msglen)
     * }
     */
    public static MemorySegment secp256k1_tagged_sha256$address() {
        return secp256k1_tagged_sha256.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_tagged_sha256(const secp256k1_context *ctx, unsigned char *hash32, const unsigned char *tag, size_t taglen, const unsigned char *msg, size_t msglen)
     * }
     */
    public static int secp256k1_tagged_sha256(MemorySegment ctx, MemorySegment hash32, MemorySegment tag, long taglen, MemorySegment msg, long msglen) {
        var mh$ = secp256k1_tagged_sha256.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_tagged_sha256", ctx, hash32, tag, taglen, msg, msglen);
            }
            return (int)mh$.invokeExact(ctx, hash32, tag, taglen, msg, msglen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_xonly_pubkey_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_xonly_pubkey_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_parse(const secp256k1_context *ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32)
     * }
     */
    public static FunctionDescriptor secp256k1_xonly_pubkey_parse$descriptor() {
        return secp256k1_xonly_pubkey_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_parse(const secp256k1_context *ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32)
     * }
     */
    public static MethodHandle secp256k1_xonly_pubkey_parse$handle() {
        return secp256k1_xonly_pubkey_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_parse(const secp256k1_context *ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32)
     * }
     */
    public static MemorySegment secp256k1_xonly_pubkey_parse$address() {
        return secp256k1_xonly_pubkey_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_parse(const secp256k1_context *ctx, secp256k1_xonly_pubkey *pubkey, const unsigned char *input32)
     * }
     */
    public static int secp256k1_xonly_pubkey_parse(MemorySegment ctx, MemorySegment pubkey, MemorySegment input32) {
        var mh$ = secp256k1_xonly_pubkey_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_xonly_pubkey_parse", ctx, pubkey, input32);
            }
            return (int)mh$.invokeExact(ctx, pubkey, input32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_xonly_pubkey_serialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_xonly_pubkey_serialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_serialize(const secp256k1_context *ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey)
     * }
     */
    public static FunctionDescriptor secp256k1_xonly_pubkey_serialize$descriptor() {
        return secp256k1_xonly_pubkey_serialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_serialize(const secp256k1_context *ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey)
     * }
     */
    public static MethodHandle secp256k1_xonly_pubkey_serialize$handle() {
        return secp256k1_xonly_pubkey_serialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_serialize(const secp256k1_context *ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey)
     * }
     */
    public static MemorySegment secp256k1_xonly_pubkey_serialize$address() {
        return secp256k1_xonly_pubkey_serialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_serialize(const secp256k1_context *ctx, unsigned char *output32, const secp256k1_xonly_pubkey *pubkey)
     * }
     */
    public static int secp256k1_xonly_pubkey_serialize(MemorySegment ctx, MemorySegment output32, MemorySegment pubkey) {
        var mh$ = secp256k1_xonly_pubkey_serialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_xonly_pubkey_serialize", ctx, output32, pubkey);
            }
            return (int)mh$.invokeExact(ctx, output32, pubkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_xonly_pubkey_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_xonly_pubkey_cmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_cmp(const secp256k1_context *ctx, const secp256k1_xonly_pubkey *pk1, const secp256k1_xonly_pubkey *pk2)
     * }
     */
    public static FunctionDescriptor secp256k1_xonly_pubkey_cmp$descriptor() {
        return secp256k1_xonly_pubkey_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_cmp(const secp256k1_context *ctx, const secp256k1_xonly_pubkey *pk1, const secp256k1_xonly_pubkey *pk2)
     * }
     */
    public static MethodHandle secp256k1_xonly_pubkey_cmp$handle() {
        return secp256k1_xonly_pubkey_cmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_cmp(const secp256k1_context *ctx, const secp256k1_xonly_pubkey *pk1, const secp256k1_xonly_pubkey *pk2)
     * }
     */
    public static MemorySegment secp256k1_xonly_pubkey_cmp$address() {
        return secp256k1_xonly_pubkey_cmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_cmp(const secp256k1_context *ctx, const secp256k1_xonly_pubkey *pk1, const secp256k1_xonly_pubkey *pk2)
     * }
     */
    public static int secp256k1_xonly_pubkey_cmp(MemorySegment ctx, MemorySegment pk1, MemorySegment pk2) {
        var mh$ = secp256k1_xonly_pubkey_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_xonly_pubkey_cmp", ctx, pk1, pk2);
            }
            return (int)mh$.invokeExact(ctx, pk1, pk2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_xonly_pubkey_from_pubkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_xonly_pubkey_from_pubkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *pk_parity, const secp256k1_pubkey *pubkey)
     * }
     */
    public static FunctionDescriptor secp256k1_xonly_pubkey_from_pubkey$descriptor() {
        return secp256k1_xonly_pubkey_from_pubkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *pk_parity, const secp256k1_pubkey *pubkey)
     * }
     */
    public static MethodHandle secp256k1_xonly_pubkey_from_pubkey$handle() {
        return secp256k1_xonly_pubkey_from_pubkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *pk_parity, const secp256k1_pubkey *pubkey)
     * }
     */
    public static MemorySegment secp256k1_xonly_pubkey_from_pubkey$address() {
        return secp256k1_xonly_pubkey_from_pubkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_from_pubkey(const secp256k1_context *ctx, secp256k1_xonly_pubkey *xonly_pubkey, int *pk_parity, const secp256k1_pubkey *pubkey)
     * }
     */
    public static int secp256k1_xonly_pubkey_from_pubkey(MemorySegment ctx, MemorySegment xonly_pubkey, MemorySegment pk_parity, MemorySegment pubkey) {
        var mh$ = secp256k1_xonly_pubkey_from_pubkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_xonly_pubkey_from_pubkey", ctx, xonly_pubkey, pk_parity, pubkey);
            }
            return (int)mh$.invokeExact(ctx, xonly_pubkey, pk_parity, pubkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_xonly_pubkey_tweak_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_xonly_pubkey_tweak_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context *ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32)
     * }
     */
    public static FunctionDescriptor secp256k1_xonly_pubkey_tweak_add$descriptor() {
        return secp256k1_xonly_pubkey_tweak_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context *ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32)
     * }
     */
    public static MethodHandle secp256k1_xonly_pubkey_tweak_add$handle() {
        return secp256k1_xonly_pubkey_tweak_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context *ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32)
     * }
     */
    public static MemorySegment secp256k1_xonly_pubkey_tweak_add$address() {
        return secp256k1_xonly_pubkey_tweak_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_tweak_add(const secp256k1_context *ctx, secp256k1_pubkey *output_pubkey, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32)
     * }
     */
    public static int secp256k1_xonly_pubkey_tweak_add(MemorySegment ctx, MemorySegment output_pubkey, MemorySegment internal_pubkey, MemorySegment tweak32) {
        var mh$ = secp256k1_xonly_pubkey_tweak_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_xonly_pubkey_tweak_add", ctx, output_pubkey, internal_pubkey, tweak32);
            }
            return (int)mh$.invokeExact(ctx, output_pubkey, internal_pubkey, tweak32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_xonly_pubkey_tweak_add_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_xonly_pubkey_tweak_add_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context *ctx, const unsigned char *tweaked_pubkey32, int tweaked_pk_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32)
     * }
     */
    public static FunctionDescriptor secp256k1_xonly_pubkey_tweak_add_check$descriptor() {
        return secp256k1_xonly_pubkey_tweak_add_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context *ctx, const unsigned char *tweaked_pubkey32, int tweaked_pk_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32)
     * }
     */
    public static MethodHandle secp256k1_xonly_pubkey_tweak_add_check$handle() {
        return secp256k1_xonly_pubkey_tweak_add_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context *ctx, const unsigned char *tweaked_pubkey32, int tweaked_pk_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32)
     * }
     */
    public static MemorySegment secp256k1_xonly_pubkey_tweak_add_check$address() {
        return secp256k1_xonly_pubkey_tweak_add_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_xonly_pubkey_tweak_add_check(const secp256k1_context *ctx, const unsigned char *tweaked_pubkey32, int tweaked_pk_parity, const secp256k1_xonly_pubkey *internal_pubkey, const unsigned char *tweak32)
     * }
     */
    public static int secp256k1_xonly_pubkey_tweak_add_check(MemorySegment ctx, MemorySegment tweaked_pubkey32, int tweaked_pk_parity, MemorySegment internal_pubkey, MemorySegment tweak32) {
        var mh$ = secp256k1_xonly_pubkey_tweak_add_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_xonly_pubkey_tweak_add_check", ctx, tweaked_pubkey32, tweaked_pk_parity, internal_pubkey, tweak32);
            }
            return (int)mh$.invokeExact(ctx, tweaked_pubkey32, tweaked_pk_parity, internal_pubkey, tweak32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_keypair_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_keypair_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_create(const secp256k1_context *ctx, secp256k1_keypair *keypair, const unsigned char *seckey)
     * }
     */
    public static FunctionDescriptor secp256k1_keypair_create$descriptor() {
        return secp256k1_keypair_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_create(const secp256k1_context *ctx, secp256k1_keypair *keypair, const unsigned char *seckey)
     * }
     */
    public static MethodHandle secp256k1_keypair_create$handle() {
        return secp256k1_keypair_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_create(const secp256k1_context *ctx, secp256k1_keypair *keypair, const unsigned char *seckey)
     * }
     */
    public static MemorySegment secp256k1_keypair_create$address() {
        return secp256k1_keypair_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_keypair_create(const secp256k1_context *ctx, secp256k1_keypair *keypair, const unsigned char *seckey)
     * }
     */
    public static int secp256k1_keypair_create(MemorySegment ctx, MemorySegment keypair, MemorySegment seckey) {
        var mh$ = secp256k1_keypair_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_keypair_create", ctx, keypair, seckey);
            }
            return (int)mh$.invokeExact(ctx, keypair, seckey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_keypair_sec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_keypair_sec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_sec(const secp256k1_context *ctx, unsigned char *seckey, const secp256k1_keypair *keypair)
     * }
     */
    public static FunctionDescriptor secp256k1_keypair_sec$descriptor() {
        return secp256k1_keypair_sec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_sec(const secp256k1_context *ctx, unsigned char *seckey, const secp256k1_keypair *keypair)
     * }
     */
    public static MethodHandle secp256k1_keypair_sec$handle() {
        return secp256k1_keypair_sec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_sec(const secp256k1_context *ctx, unsigned char *seckey, const secp256k1_keypair *keypair)
     * }
     */
    public static MemorySegment secp256k1_keypair_sec$address() {
        return secp256k1_keypair_sec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_keypair_sec(const secp256k1_context *ctx, unsigned char *seckey, const secp256k1_keypair *keypair)
     * }
     */
    public static int secp256k1_keypair_sec(MemorySegment ctx, MemorySegment seckey, MemorySegment keypair) {
        var mh$ = secp256k1_keypair_sec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_keypair_sec", ctx, seckey, keypair);
            }
            return (int)mh$.invokeExact(ctx, seckey, keypair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_keypair_pub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_keypair_pub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_pub(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair)
     * }
     */
    public static FunctionDescriptor secp256k1_keypair_pub$descriptor() {
        return secp256k1_keypair_pub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_pub(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair)
     * }
     */
    public static MethodHandle secp256k1_keypair_pub$handle() {
        return secp256k1_keypair_pub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_pub(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair)
     * }
     */
    public static MemorySegment secp256k1_keypair_pub$address() {
        return secp256k1_keypair_pub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_keypair_pub(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_keypair *keypair)
     * }
     */
    public static int secp256k1_keypair_pub(MemorySegment ctx, MemorySegment pubkey, MemorySegment keypair) {
        var mh$ = secp256k1_keypair_pub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_keypair_pub", ctx, pubkey, keypair);
            }
            return (int)mh$.invokeExact(ctx, pubkey, keypair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_keypair_xonly_pub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_keypair_xonly_pub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_xonly_pub(const secp256k1_context *ctx, secp256k1_xonly_pubkey *pubkey, int *pk_parity, const secp256k1_keypair *keypair)
     * }
     */
    public static FunctionDescriptor secp256k1_keypair_xonly_pub$descriptor() {
        return secp256k1_keypair_xonly_pub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_xonly_pub(const secp256k1_context *ctx, secp256k1_xonly_pubkey *pubkey, int *pk_parity, const secp256k1_keypair *keypair)
     * }
     */
    public static MethodHandle secp256k1_keypair_xonly_pub$handle() {
        return secp256k1_keypair_xonly_pub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_xonly_pub(const secp256k1_context *ctx, secp256k1_xonly_pubkey *pubkey, int *pk_parity, const secp256k1_keypair *keypair)
     * }
     */
    public static MemorySegment secp256k1_keypair_xonly_pub$address() {
        return secp256k1_keypair_xonly_pub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_keypair_xonly_pub(const secp256k1_context *ctx, secp256k1_xonly_pubkey *pubkey, int *pk_parity, const secp256k1_keypair *keypair)
     * }
     */
    public static int secp256k1_keypair_xonly_pub(MemorySegment ctx, MemorySegment pubkey, MemorySegment pk_parity, MemorySegment keypair) {
        var mh$ = secp256k1_keypair_xonly_pub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_keypair_xonly_pub", ctx, pubkey, pk_parity, keypair);
            }
            return (int)mh$.invokeExact(ctx, pubkey, pk_parity, keypair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_keypair_xonly_tweak_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_keypair_xonly_tweak_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_xonly_tweak_add(const secp256k1_context *ctx, secp256k1_keypair *keypair, const unsigned char *tweak32)
     * }
     */
    public static FunctionDescriptor secp256k1_keypair_xonly_tweak_add$descriptor() {
        return secp256k1_keypair_xonly_tweak_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_xonly_tweak_add(const secp256k1_context *ctx, secp256k1_keypair *keypair, const unsigned char *tweak32)
     * }
     */
    public static MethodHandle secp256k1_keypair_xonly_tweak_add$handle() {
        return secp256k1_keypair_xonly_tweak_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_keypair_xonly_tweak_add(const secp256k1_context *ctx, secp256k1_keypair *keypair, const unsigned char *tweak32)
     * }
     */
    public static MemorySegment secp256k1_keypair_xonly_tweak_add$address() {
        return secp256k1_keypair_xonly_tweak_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_keypair_xonly_tweak_add(const secp256k1_context *ctx, secp256k1_keypair *keypair, const unsigned char *tweak32)
     * }
     */
    public static int secp256k1_keypair_xonly_tweak_add(MemorySegment ctx, MemorySegment keypair, MemorySegment tweak32) {
        var mh$ = secp256k1_keypair_xonly_tweak_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_keypair_xonly_tweak_add", ctx, keypair, tweak32);
            }
            return (int)mh$.invokeExact(ctx, keypair, tweak32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_nonce_function_bip340$constants {
        public static final AddressLayout LAYOUT = secp256k1_h.C_POINTER;
        public static final MemorySegment SEGMENT = secp256k1_h.findOrThrow("secp256k1_nonce_function_bip340").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340
     * }
     */
    public static AddressLayout secp256k1_nonce_function_bip340$layout() {
        return secp256k1_nonce_function_bip340$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340
     * }
     */
    public static MemorySegment secp256k1_nonce_function_bip340$segment() {
        return secp256k1_nonce_function_bip340$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340
     * }
     */
    public static MemorySegment secp256k1_nonce_function_bip340() {
        return secp256k1_nonce_function_bip340$constants.SEGMENT.get(secp256k1_nonce_function_bip340$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340
     * }
     */
    public static void secp256k1_nonce_function_bip340(MemorySegment varValue) {
        secp256k1_nonce_function_bip340$constants.SEGMENT.set(secp256k1_nonce_function_bip340$constants.LAYOUT, 0L, varValue);
    }

    private static class secp256k1_schnorrsig_sign32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_schnorrsig_sign32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign32(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32)
     * }
     */
    public static FunctionDescriptor secp256k1_schnorrsig_sign32$descriptor() {
        return secp256k1_schnorrsig_sign32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign32(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32)
     * }
     */
    public static MethodHandle secp256k1_schnorrsig_sign32$handle() {
        return secp256k1_schnorrsig_sign32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign32(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32)
     * }
     */
    public static MemorySegment secp256k1_schnorrsig_sign32$address() {
        return secp256k1_schnorrsig_sign32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign32(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32)
     * }
     */
    public static int secp256k1_schnorrsig_sign32(MemorySegment ctx, MemorySegment sig64, MemorySegment msg32, MemorySegment keypair, MemorySegment aux_rand32) {
        var mh$ = secp256k1_schnorrsig_sign32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_schnorrsig_sign32", ctx, sig64, msg32, keypair, aux_rand32);
            }
            return (int)mh$.invokeExact(ctx, sig64, msg32, keypair, aux_rand32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_schnorrsig_sign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_schnorrsig_sign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32)
     * }
     */
    public static FunctionDescriptor secp256k1_schnorrsig_sign$descriptor() {
        return secp256k1_schnorrsig_sign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32)
     * }
     */
    public static MethodHandle secp256k1_schnorrsig_sign$handle() {
        return secp256k1_schnorrsig_sign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32)
     * }
     */
    public static MemorySegment secp256k1_schnorrsig_sign$address() {
        return secp256k1_schnorrsig_sign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, const unsigned char *aux_rand32)
     * }
     */
    public static int secp256k1_schnorrsig_sign(MemorySegment ctx, MemorySegment sig64, MemorySegment msg32, MemorySegment keypair, MemorySegment aux_rand32) {
        var mh$ = secp256k1_schnorrsig_sign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_schnorrsig_sign", ctx, sig64, msg32, keypair, aux_rand32);
            }
            return (int)mh$.invokeExact(ctx, sig64, msg32, keypair, aux_rand32);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_schnorrsig_sign_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_LONG,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_schnorrsig_sign_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign_custom(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_schnorrsig_extraparams *extraparams)
     * }
     */
    public static FunctionDescriptor secp256k1_schnorrsig_sign_custom$descriptor() {
        return secp256k1_schnorrsig_sign_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign_custom(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_schnorrsig_extraparams *extraparams)
     * }
     */
    public static MethodHandle secp256k1_schnorrsig_sign_custom$handle() {
        return secp256k1_schnorrsig_sign_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign_custom(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_schnorrsig_extraparams *extraparams)
     * }
     */
    public static MemorySegment secp256k1_schnorrsig_sign_custom$address() {
        return secp256k1_schnorrsig_sign_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_sign_custom(const secp256k1_context *ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_keypair *keypair, secp256k1_schnorrsig_extraparams *extraparams)
     * }
     */
    public static int secp256k1_schnorrsig_sign_custom(MemorySegment ctx, MemorySegment sig64, MemorySegment msg, long msglen, MemorySegment keypair, MemorySegment extraparams) {
        var mh$ = secp256k1_schnorrsig_sign_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_schnorrsig_sign_custom", ctx, sig64, msg, msglen, keypair, extraparams);
            }
            return (int)mh$.invokeExact(ctx, sig64, msg, msglen, keypair, extraparams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_schnorrsig_verify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_LONG,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_schnorrsig_verify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_verify(const secp256k1_context *ctx, const unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_xonly_pubkey *pubkey)
     * }
     */
    public static FunctionDescriptor secp256k1_schnorrsig_verify$descriptor() {
        return secp256k1_schnorrsig_verify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_verify(const secp256k1_context *ctx, const unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_xonly_pubkey *pubkey)
     * }
     */
    public static MethodHandle secp256k1_schnorrsig_verify$handle() {
        return secp256k1_schnorrsig_verify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_verify(const secp256k1_context *ctx, const unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_xonly_pubkey *pubkey)
     * }
     */
    public static MemorySegment secp256k1_schnorrsig_verify$address() {
        return secp256k1_schnorrsig_verify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_schnorrsig_verify(const secp256k1_context *ctx, const unsigned char *sig64, const unsigned char *msg, size_t msglen, const secp256k1_xonly_pubkey *pubkey)
     * }
     */
    public static int secp256k1_schnorrsig_verify(MemorySegment ctx, MemorySegment sig64, MemorySegment msg, long msglen, MemorySegment pubkey) {
        var mh$ = secp256k1_schnorrsig_verify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_schnorrsig_verify", ctx, sig64, msg, msglen, pubkey);
            }
            return (int)mh$.invokeExact(ctx, sig64, msg, msglen, pubkey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class secp256k1_ecdh_hash_function_sha256$constants {
        public static final AddressLayout LAYOUT = secp256k1_h.C_POINTER;
        public static final MemorySegment SEGMENT = secp256k1_h.findOrThrow("secp256k1_ecdh_hash_function_sha256").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_sha256
     * }
     */
    public static AddressLayout secp256k1_ecdh_hash_function_sha256$layout() {
        return secp256k1_ecdh_hash_function_sha256$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_sha256
     * }
     */
    public static MemorySegment secp256k1_ecdh_hash_function_sha256$segment() {
        return secp256k1_ecdh_hash_function_sha256$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_sha256
     * }
     */
    public static MemorySegment secp256k1_ecdh_hash_function_sha256() {
        return secp256k1_ecdh_hash_function_sha256$constants.SEGMENT.get(secp256k1_ecdh_hash_function_sha256$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_sha256
     * }
     */
    public static void secp256k1_ecdh_hash_function_sha256(MemorySegment varValue) {
        secp256k1_ecdh_hash_function_sha256$constants.SEGMENT.set(secp256k1_ecdh_hash_function_sha256$constants.LAYOUT, 0L, varValue);
    }

    private static class secp256k1_ecdh_hash_function_default$constants {
        public static final AddressLayout LAYOUT = secp256k1_h.C_POINTER;
        public static final MemorySegment SEGMENT = secp256k1_h.findOrThrow("secp256k1_ecdh_hash_function_default").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_default
     * }
     */
    public static AddressLayout secp256k1_ecdh_hash_function_default$layout() {
        return secp256k1_ecdh_hash_function_default$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_default
     * }
     */
    public static MemorySegment secp256k1_ecdh_hash_function_default$segment() {
        return secp256k1_ecdh_hash_function_default$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_default
     * }
     */
    public static MemorySegment secp256k1_ecdh_hash_function_default() {
        return secp256k1_ecdh_hash_function_default$constants.SEGMENT.get(secp256k1_ecdh_hash_function_default$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_default
     * }
     */
    public static void secp256k1_ecdh_hash_function_default(MemorySegment varValue) {
        secp256k1_ecdh_hash_function_default$constants.SEGMENT.set(secp256k1_ecdh_hash_function_default$constants.LAYOUT, 0L, varValue);
    }

    private static class secp256k1_ecdh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            secp256k1_h.C_INT,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER,
            secp256k1_h.C_POINTER
        );

        public static final MemorySegment ADDR = secp256k1_h.findOrThrow("secp256k1_ecdh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdh(const secp256k1_context *ctx, unsigned char *output, const secp256k1_pubkey *pubkey, const unsigned char *seckey, secp256k1_ecdh_hash_function hashfp, void *data)
     * }
     */
    public static FunctionDescriptor secp256k1_ecdh$descriptor() {
        return secp256k1_ecdh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdh(const secp256k1_context *ctx, unsigned char *output, const secp256k1_pubkey *pubkey, const unsigned char *seckey, secp256k1_ecdh_hash_function hashfp, void *data)
     * }
     */
    public static MethodHandle secp256k1_ecdh$handle() {
        return secp256k1_ecdh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int secp256k1_ecdh(const secp256k1_context *ctx, unsigned char *output, const secp256k1_pubkey *pubkey, const unsigned char *seckey, secp256k1_ecdh_hash_function hashfp, void *data)
     * }
     */
    public static MemorySegment secp256k1_ecdh$address() {
        return secp256k1_ecdh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int secp256k1_ecdh(const secp256k1_context *ctx, unsigned char *output, const secp256k1_pubkey *pubkey, const unsigned char *seckey, secp256k1_ecdh_hash_function hashfp, void *data)
     * }
     */
    public static int secp256k1_ecdh(MemorySegment ctx, MemorySegment output, MemorySegment pubkey, MemorySegment seckey, MemorySegment hashfp, MemorySegment data) {
        var mh$ = secp256k1_ecdh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("secp256k1_ecdh", ctx, output, pubkey, seckey, hashfp, data);
            }
            return (int)mh$.invokeExact(ctx, output, pubkey, seckey, hashfp, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int SECP256K1_FLAGS_TYPE_MASK = (int)255L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_FLAGS_TYPE_MASK 255
     * }
     */
    public static int SECP256K1_FLAGS_TYPE_MASK() {
        return SECP256K1_FLAGS_TYPE_MASK;
    }
    private static final int SECP256K1_FLAGS_TYPE_CONTEXT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_FLAGS_TYPE_CONTEXT 1
     * }
     */
    public static int SECP256K1_FLAGS_TYPE_CONTEXT() {
        return SECP256K1_FLAGS_TYPE_CONTEXT;
    }
    private static final int SECP256K1_FLAGS_TYPE_COMPRESSION = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_FLAGS_TYPE_COMPRESSION 2
     * }
     */
    public static int SECP256K1_FLAGS_TYPE_COMPRESSION() {
        return SECP256K1_FLAGS_TYPE_COMPRESSION;
    }
    private static final int SECP256K1_FLAGS_BIT_CONTEXT_VERIFY = (int)256L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_FLAGS_BIT_CONTEXT_VERIFY 256
     * }
     */
    public static int SECP256K1_FLAGS_BIT_CONTEXT_VERIFY() {
        return SECP256K1_FLAGS_BIT_CONTEXT_VERIFY;
    }
    private static final int SECP256K1_FLAGS_BIT_CONTEXT_SIGN = (int)512L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_FLAGS_BIT_CONTEXT_SIGN 512
     * }
     */
    public static int SECP256K1_FLAGS_BIT_CONTEXT_SIGN() {
        return SECP256K1_FLAGS_BIT_CONTEXT_SIGN;
    }
    private static final int SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY 1024
     * }
     */
    public static int SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY() {
        return SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY;
    }
    private static final int SECP256K1_FLAGS_BIT_COMPRESSION = (int)256L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_FLAGS_BIT_COMPRESSION 256
     * }
     */
    public static int SECP256K1_FLAGS_BIT_COMPRESSION() {
        return SECP256K1_FLAGS_BIT_COMPRESSION;
    }
    private static final int SECP256K1_CONTEXT_NONE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_CONTEXT_NONE 1
     * }
     */
    public static int SECP256K1_CONTEXT_NONE() {
        return SECP256K1_CONTEXT_NONE;
    }
    private static final int SECP256K1_CONTEXT_VERIFY = (int)257L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_CONTEXT_VERIFY 257
     * }
     */
    public static int SECP256K1_CONTEXT_VERIFY() {
        return SECP256K1_CONTEXT_VERIFY;
    }
    private static final int SECP256K1_CONTEXT_SIGN = (int)513L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_CONTEXT_SIGN 513
     * }
     */
    public static int SECP256K1_CONTEXT_SIGN() {
        return SECP256K1_CONTEXT_SIGN;
    }
    private static final int SECP256K1_CONTEXT_DECLASSIFY = (int)1025L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_CONTEXT_DECLASSIFY 1025
     * }
     */
    public static int SECP256K1_CONTEXT_DECLASSIFY() {
        return SECP256K1_CONTEXT_DECLASSIFY;
    }
    private static final int SECP256K1_EC_COMPRESSED = (int)258L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_EC_COMPRESSED 258
     * }
     */
    public static int SECP256K1_EC_COMPRESSED() {
        return SECP256K1_EC_COMPRESSED;
    }
    private static final int SECP256K1_EC_UNCOMPRESSED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SECP256K1_EC_UNCOMPRESSED 2
     * }
     */
    public static int SECP256K1_EC_UNCOMPRESSED() {
        return SECP256K1_EC_UNCOMPRESSED;
    }
}

